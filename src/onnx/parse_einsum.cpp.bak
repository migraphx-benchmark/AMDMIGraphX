/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-2023 Advanced Micro Devices, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <migraphx/onnx/op_parser.hpp>
#include <migraphx/ranges.hpp>
#include <migraphx/make_op.hpp>
#include <migraphx/instruction.hpp>

namespace migraphx {
inline namespace MIGRAPHX_INLINE_NS {
namespace onnx {

struct parse_einsum : op_parser<parse_einsum>
{
    std::vector<op_desc> operators() const { return {{"Einsum"}}; }

    instruction_ref parse(const op_desc& /*opd*/,
                          const onnx_parser& /*parser*/,
                          const onnx_parser::node_info& info,
                          const std::vector<instruction_ref>& args) const
    {
        if(not contains(info.attributes, "equation"))
        {
            MIGRAPHX_THROW("Equation attribute is required");
        }

        const auto equation = info.attributes.at("equation").s();
        /*Delete*/
        std::cout << std::endl;
        std::cout << equation << std::endl;
        /*Delete*/

        std::cout << "Parsing einsum" << std::endl;
        const auto [input_terms, output_term] = parse_equation_alternate(equation);
        /*Delete*/
        for(auto ii : input_terms)
        {
            std::cout << ii << " ";
        }
        std::cout << std::endl;
        std::cout << output_term << std::endl;
        /*Delete*/

        if(input_terms.size() != args.size())
        {
            MIGRAPHX_THROW(
                "Number of terms in the input equation - " + std::to_string(input_terms.size()) +
                " does not match the number of input tensors " + std::to_string(args.size()));
        }
    }

    std::tuple<std::vector<std::string>, std::string> parse_equation(std::string equation) const
    {
        std::tuple<std::vector<std::string>, std::string> ret;
        auto& [input_terms, output_term] = ret;

        equation.erase(std::remove(equation.begin(), equation.end(), ' '), equation.end());

        const auto split_equation = split(equation, "->");
        if(split_equation.size() > 2)
        {
            MIGRAPHX_THROW("Einsum equation may contain at most one '->'");
        }

        std::string_view left_side{split_equation[0]};
        std::string_view right_side =
            split_equation.size() == 1 ? std::string_view{} : split_equation[1];

        const auto terms = split(left_side, ",");
        for(auto& term : terms)
        {
            input_terms.emplace_back(process_term(term));
        }

        if(right_side.empty())
        {
            constexpr auto f = [](std::string& acc, std::string term) {
                // TODO
                // Eliminate any * symbols from term
                std::sort(term.begin(), term.end());
                std::string unique;
                std::set_symmetric_difference(
                    acc.begin(), acc.end(), term.begin(), term.end(), std::back_inserter(unique));

                return unique;
            };
            output_term = std::accumulate(input_terms.begin(), input_terms.end(), std::string{}, f);
        }
        else
        {
            output_term = process_term(right_side);
        }

        return ret;
    }

    std::tuple<std::vector<std::string>, std::string>
    parse_equation_alternate(std::string_view equation) const
    {
        std::tuple<std::vector<std::string>, std::string> ret;
        auto& [input_terms, output_term] = ret;

        std::string term;
        bool has_ellipsis  = false;
        bool explicit_form = false;

        for(int i = 0; i < equation.size(); ++i)
        {
            const char c = equation[i];
            switch(c)
            {
            case ' ': break;
            case '-':
                if(explicit_form)
                {
                    MIGRAPHX_THROW("Einsum equation has multiple '->' symbols");
                }
                if(i + 1 >= equation.size() || equation[i + 1] != '>')
                {
                    MIGRAPHX_THROW("Invalid '->' in einsum equation");
                }
                ++i;
                explicit_form = true;
                [[fallthrough]];
            case ',':
                has_ellipsis = false;
                input_terms.emplace_back(term);
                term.clear();
                break;
            case '.':
                if(has_ellipsis)
                {
                    MIGRAPHX_THROW("Ellipsis can only appear once per einsum equation term");
                }
                if(i + 2 >= equation.size() || equation[i + 1] != '.' || equation[i + 2] != '.')
                {
                    MIGRAPHX_THROW("Incomplete ellipsis in einsum equation " +
                                   std::string(equation));
                }
                i += 2;
                has_ellipsis = true;
                term += '*';
                break;
            default:
                if(!std::isalpha(c))
                {
                    MIGRAPHX_THROW(std::string("Invalid character '") + c +
                                   "' in einsum equation term");
                }
                term += c;
            }
        }

        if(explicit_form)
        {
            output_term = term;
        }
        else
        {
            input_terms.push_back(term);
        }

        return ret;
    }

    std::vector<std::string_view> split(std::string_view str, std::string_view delim) const
    {
        std::vector<std::string_view> ret;
        std::string_view::size_type prev = 0u, cur = 0u;
        while((cur = str.find(delim, prev)) != std::string_view::npos)
        {
            ret.emplace_back(str.substr(prev, cur - prev));
            prev = cur + delim.size();
        }
        ret.emplace_back(str.substr(prev, std::string_view::npos));

        return ret;
    }

    std::string process_term(std::string_view term) const
    {
        bool processing_ellipsis = false;
        size_t period_count      = 0u;

        std::string modified_term;
        modified_term.reserve(term.size());

        for(const auto label : term)
        {
            if(std::isalpha(label))
            {
                // Catch '.i', '..i', etc.
                if(processing_ellipsis)
                {
                    MIGRAPHX_THROW("Stray '.' found in equation term " + std::string{term});
                }
                modified_term += label;
            }
            else if(label == '.')
            {
                processing_ellipsis = true;
                ++period_count;
                // Catch '....', '...i...', etc.
                if(period_count > 3)
                {
                    MIGRAPHX_THROW("Stray '.' found in eqution term " + std::string{term});
                }
                if(period_count == 3)
                {
                    processing_ellipsis = false;
                    // Replace ellipsis with * to make life easier down the line
                    modified_term += '*';
                }
            }
            else
            {
                MIGRAPHX_THROW("Einsum equation terms may only contain lower and upper case "
                               "letters, and ellipses");
            }
        }

        return modified_term;
    }
};

} // namespace onnx
} // namespace MIGRAPHX_INLINE_NS
} // namespace migraphx